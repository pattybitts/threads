<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Threads of the Pattern</title>
</head>

<body onload="init('{{book_file}}', {{position}})">
    <h2>Interactive Text Parser</h2>
    <!--  
        This is admittedly an ugly fix to our problem of interfacing between the page and python.
        We use a hidden form with fields corresponding to the data to be saved.
        The corresponding function populates the fields and submits the form.
        On the python side, we use request.form to pull the data into the database, perform server-side
        operations, then re-upload the data to preserve the context.
        Options for elegant asynchronous data-transfer with AJAX may come, but it's essential for now that
        we begin building the database so we can create initial data models.
    -->
    <form id="gen_form" action="/generate_summary" method="post">
        <textarea id="known_names" name="kn_form">{{known_names}}</textarea>
        <input type="text" id="save_file" name="sf_form" value='{{save_file}}'>
        <input type="text" id="position" name="po_form" value='{{position}}'>
        <input type="text" id="chapter" name="ch_form" value='{{chapter}}'>
        <input type="text" id="primary" name="pr_form" value='{{primary}}'>
        <textarea id="locations" name="lo_form">{{locations}}</textarea>
        <textarea id="description" name="de_form">{{description}}</textarea>
        <input type="text" id="wordcount" name="wo_form" value='{{wordcount}}'>
        <textarea id="mentions" name="me_form">{{mentions}}</textarea>
        <textarea id="quotes" name="qu_form">{{quotes}}</textarea>
        <textarea id="char_events" name="ce_form">{{char_events}}</textarea>
        <input type="submit" value="Submit">
    </form>
    <div id="main_div">
        <div id="page_div">
            <pre id="page_text"></pre>
            <div id="page_quotes"></div>
        </div>
        <div id="utils_div">
            <div id="inputs_div">
                <div id="scene_div">
                    Scene Info:<br /><br />
                    <label for="chapter_box">Chapter Name:</label>
                    <input type="text" id="chapter_box" name="chapter_box"><br />
                    <label for="primary_box">Primary Character Name:</label>
                    <input type="text" id="primary_box" name="primary_box"><br />
                    <label for="locations_box">Location Names:</label>
                    <textarea id="locations_box" name="locations_box"></textarea><br />
                    <label for="description_box">Brief Description:</label>
                    <textarea id="description_box" name="description_box"></textarea><br />
                </div>
                <div id="char_div">
                    Character Update:<br /><br />
                    <label for="char_name_box">Character Name:</label>
                    <input type="text" id="char_name_box" name="char_name_box" /><br />
                    <label for="aliases_box">New Aliases:</label>
                    <textarea id="aliases_box" name="aliases_box"></textarea><br />
                    <label for="joins_box">Joined Characters:</label>
                    <textarea id="joins_box" name="joins_box"></textarea><br />
                    <label for="tags_box">New Tags:</label>
                    <textarea id="tags_box" name="tags_box"></textarea><br />
                </div>
            </div>
            <div id="buttons_div">
                <button id="next_page_button" class="button light">Next Page</button>
                <button id="event_button" class="button light">Char Event</button>
                <button id="add_button" class="button light">Add Name</button>
                <button id="quote_button" class="button light">Set Quote</button>
                <button id="reset_button" class="button light">Reset</button>
                <button id="summary_button" class="button light">Sum</button>
                <button id="mark_button" class="button light">Mark Scene</button>
                <button id="save_button" class="button light">Save Scene</button>
                <button id="diagnostic_button" class="button light">Diagnostic</button>
            </div>
            <div id="hotkeys_log_div">
                <div id="hotkeys">
                    <div id="fixed_hotkeys"></div>
                    <div id="char_hotkeys"></div>
                </div>
                <div id="log">
                    Log Output:
                    <textarea id="log_box" readonly></textarea>
                </div>
            </div>
        </div>
    </div>
</body>
</html>

<style>
    * {
        font-family: Calibri;
    }
    *:focus {
        outline: none;
    }

    div {
        position: relative;
        top: 0px;
        left: 0px;
        display: flex;
        align-items: flex-start;
        border-radius: 5px;
        border: 1px solid black;
        color: black;
        height: 100%;
        width: 100%;
        flex-direction: row;
    }
    #main_div {
        height: 700px;
    }
    #page_div {
        width: 50%;
        flex-direction: column;
    }
    #utils_div {
        width: 50%;
        flex-direction: column;
    }
    #page_text {
        height: 50%;
    }
    #page_quotes {
        height: 50%;
        flex-direction: column;
    }
    #inputs_div {
        height: 50%;
    }
    #scene_div {
        flex-direction: column;
    }
    #char_div {
        flex-direction: column;
    }
    #buttons_div {
        height: 10%;
    }
    #hotkeys_log_div {
        height: 40%;
    }
    #hotkeys {
        width: 50%;
    }
    #fixed_hotkeys {
        flex-direction: column;
    }
    #char_hotkeys {
        flex-direction: column;
    }
    #log {
        width: 50%;
        flex-direction: column;
    }

    #log_box {
        width: 100%;
        height: 100%;
        overflow: hidden;
        resize: none;
        overflow-y: scroll;
        overflow-x: scroll;
        font-family: 'Lucida Console';
    }

    .button {
        height: 50px;
        width: 50px;
        border-radius: 8px;
        font-size: 12px;
        text-align: center;
        text-decoration: none;
        transition-duration: 0.2s;
        border: 1px solid black;
    }
    .button:hover {
        background-color: lightgray;
    }
    .button:active {
        background-color: grey;
    }

    .light {
        background-color: white;
        color: black;
    }
    .dark {
        background-color: black;
        color: white;
    }

    .hgreen {
        background-color:  lime;
    }
    .hyellow {
        background-color: yellow;
    }
    .hred {
        background-color: palevioletred;
    }

    .selected {
        background-color: yellow;
    }
    .assigned {
        background-color: lime;
    }

</style>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
<script>
    //page utilities
    var active_hotkeys = new Map();
    var input_focus = false;
    var last_page = false;

    var full_text = "";
    var abs_char_count = 0;

    var page_start = 0;
    var page_text = "";
    var page_wordcount = 0;
    var page_mentions = new Map();
    var page_quotes = new Map();

    //scene data storage (will be saved via form)
    var scene_wordcount = 0;
    var scene_mentions = new Map();
    var scene_quotes = new Map();
    var char_events = [];
    var scene_end = null;
    
    var known_names = [];
    var hot_names = new Map();

    $(document).ready(function () {
        $(document).keypress(hotkey);
        $("input").focus(function () {
            input_focus = true;
        });
        $("input").blur(function () {
            input_focus = false;
        });
        $("textarea").focus(function () {
            input_focus = true;
        });
        $("textarea").blur(function () {
            input_focus = false;
        });
        $('#next_page_button').click(next_page);
        $('#add_button').click(add_name);
        $('#summary_button').click(generate_summary);
        $('#event_button').click(character_event);
        $('#mark_button').click(mark_scene);
        $('#diagnostic_button').click(diagnostic);
    });

    function init(book_file, position) {
        active_hotkeys.set(110, ["next_page", []]); //n
        active_hotkeys.set(97, ["add_name", []]); //a
        active_hotkeys.set(115, ["generate_summary", []]); //s
        active_hotkeys.set(99, ["character_event", []]); //c
        active_hotkeys.set(109, ["mark_scene", []]); //m
        active_hotkeys.set(100, ["diagnostic", []]); //d

        $.get(book_file, read_text);
        abs_char_count = position;
        known_names = $('#known_names').text().split(',');
        for (var i = 0; i < 10; i++) {
            hot_names.set(i, ["", 0]);
        }

        $('#log_box').text("Log output will appear here:");
        $('#page_text').text("Page text will appear here:");
        $('#page_quotes').text("Page quotes will appear here:");
        $('#fixed_hotkeys').html("<b>Fixed Hotkeys:</b>" +
            "Next Page: N<br />" +
            "Add Character: A<br />" +
            "Character Event: C<br />" +
            "Mark Scene End: M<br />" +
            "Generate Summary: S");
        $('#char_hotkeys').html("<b>Character Hotkeys:</b>");
        //this would be a small qol, but it's crashing the page (running before fully initialized?)
        //TODO
        //next_page();
    }

    function log(string, clear = false) {
        if (clear) {
            $('#log_box').text("");
        }
        $('#log_box').text($('#log_box').text() + "\n" + string);
    }

    function read_text(data, status) {
        if (status == "success") {
            full_text = data;
        } else {
            full_text = "Unexpected error reading text file";
        }
    }

    function hotkey(key) {
        //log(key.which);
        if (active_hotkeys.has(key.which) && input_focus == false) {
            func = String(active_hotkeys.get(key.which)[0]);
            args = active_hotkeys.get(key.which)[1];
            window[func](args);
        }
    }

    function save_page_to_scene() {
        //checking that all previous quotes are assigned
        var checked_quotes = true;
        var all_quotes = document.getElementsByClassName('quote_div');
        for (var i = 0, len = all_quotes.length | 0; i < len; i = i + 1) {
            var quote_div = all_quotes[i];
            if (!quote_div.classList.contains("assigned")) {
                checked_quotes = false;
                break;
            }
        }
        if (!checked_quotes) {
            return false;
        }
        //adding previous page info to scene_arrays
        for (let key of page_mentions.keys()) {
            add_to_map(scene_mentions, key, page_mentions.get(key));
        }
        for (let key of page_quotes.keys()) {
            add_to_map(scene_quotes, key, page_quotes.get(key));
        }
        scene_wordcount += page_wordcount;
        page_start = abs_char_count;
        return true;
    }

    function next_page() {
        //checking that previous data has been saved
        if (scene_end !== null && !last_page) {
            log("ERROR: cannot continue until previous scene is saved");
            return;
        }
        if (!last_page) {
            if (!save_page_to_scene()) {
                log("ERROR: Cannot start until all quotes on previous page are assigned");
                return;
            }
        }

        log("New Page");

        page_quotes.clear();
        var quotes = [];
        var lines = 0;
        var char_inc = 0;
        var in_quote = false;
        var quote_start = 0;
        while ((quotes.length < 5 && lines < 17) || in_quote) {
            next_char = full_text.charAt(abs_char_count + char_inc++);
            if (next_char == "\n") {
                lines++;
            }
            if (next_char == "\"") {
                if (!in_quote) {
                    in_quote = true;
                    quote_start = abs_char_count + char_inc;
                } else {
                    in_quote = false;
                    var quote = full_text.substring(quote_start, abs_char_count + char_inc - 1);
                    quote.replace("\n", " ");
                    quotes.push(quote);
                }
            }
            if (scene_end !== null && char_inc >= scene_end) {
                break;
            }
        }
        $('#page_quotes').empty();
        for (let q of quotes) {
            var quote_html = "<div onclick='select_quote(this)' class='quote_div'>\"" + String(q) + "\"</div>";
            $('#page_quotes').append(quote_html);
        }
        $(".quote_div:first").addClass('selected');

        page_text = full_text.substr(abs_char_count, char_inc);
        process_page_text();
        update_hotkeys(!last_page);

        abs_char_count += char_inc;
    }

    function character_event() {
        var char_name = get_val('char_name_box');
        if (char_name == "") {
            log("ERROR: Character Events must have a primary name.");
            return;
        } else {
            add_to_array(known_names, char_name);
            add_to_hot_names(char_name);
        }
        var char_aliases = get_val('aliases_box').split(/[\v\r\n]+(?!$)/);
        for (ca of char_aliases) {
            add_to_array(known_names, ca);
            add_to_hot_names(ca);
        }
        process_page_text();
        add_to_array(char_events, [
            get_val('char_name_box', true),
            get_val('aliases_box', true).split(/[\v\r\n]+(?!$)/),
            get_val('joins_box', true).split(/[\v\r\n]+(?!$)/),
            get_val('tags_box', true).split(/[\v\r\n]+(?!$)/),
        ]);
        log("Submitted Character Event for: " + char_name);
    }

    function update_hotkeys(inc_counters=false) {
        var char_hotkey_text = "<b>Character Hotkeys:</b>";
        for (let key of hot_names.keys()) {
            var name_val = hot_names.get(key)[0];
            if (name_val != "") {
                active_hotkeys.set(48 + key, ["set_quote", [name_val]]); //48 is key 0
                char_hotkey_text += name_val + ": " + key + "<br />";
                if (inc_counters) {hot_names.set(key, [name_val, hot_names.get(key)[1] + 1]);}
            }
        }
        $('#char_hotkeys').html(char_hotkey_text);
    }

    function process_page_text() {
        var html_text = page_text;
        var potential_matches = known_names;
        var potential_name = "";
        var best_matches = [];
        var page_caps = new Map();
        var page_words = page_text.split(/[\s-."]+(?!$)/);

        page_mentions.clear();
        page_wordcount = page_words.length;

        //can maybe be refactored now that i can use break
        for (let p of page_words) {
            if (potential_name != "") {
                potential_name += " " + /^"*(['A-Za-z]*)/.exec(p)[1];
            } else if (/^"*([A-Z].*)/.test(p)) {
                potential_name = /^"*(['A-Za-z]*)/.exec(p)[1];
            }
            if (potential_name != "") {
                //log("pm: " + potential_name);
                potential_name = potential_name.replace("'s", "");
                var pm_reg = new RegExp(potential_name + "(\\s*$|\\s+)");
                potential_matches = potential_matches.filter(pm => pm.search(pm_reg) >= 0);
                if (potential_matches.length > 0) {
                    best_matches = potential_matches.filter(pm => pm == potential_name);
                } else {
                    if (best_matches.length > 0) {
                        //log("bm: " + best_matches);
                        add_to_map(page_mentions, best_matches[0]);
                        best_matches = [];
                        potential_matches = known_names;
                    } else {
                        if (/[\s-."]+(?!$)/.test(potential_name)) { potential_name = potential_name.split(/[\s-."]+(?!$)/)[0];}
                        add_to_map(page_caps, potential_name);
                        potential_name = "";
                        potential_matches = known_names;
                    }
                    if (/^"*([A-Z].*)/.test(p)) {
                        potential_name = /^"*(['A-Za-z]*)/.exec(p)[1];
                        potential_name = potential_name.replace("'s", "");
                        pm_reg = new RegExp(potential_name + "(\\s*$|\\s+)");
                        potential_matches = potential_matches.filter(pm => pm.search(pm_reg) >= 0);
                        if (potential_matches.length > 0) {
                            best_matches = potential_matches.filter(pm => pm == potential_name);
                        }
                    } else {
                        potential_name = "";
                    }
                }
            }
        }
        var name_reg = null;
        var name_rep = "";
        var sorted_pm = new Map([...page_mentions.entries()].sort());
        for (let pm of sorted_pm.keys()) {
            name_reg = new RegExp("(?<!>)(" + pm + ")(?![<\\w])", "g");
            name_rep = "<span class='hgreen'>" + pm + "</span>";
            html_text = html_text.replace(name_reg, name_rep);

            add_to_hot_names(pm);
        }
        var sorted_pc = new Map([...page_caps.entries()].sort());
        for (let pc of sorted_pc.keys()) {
            name_reg = new RegExp("(?<!>)(" + pc + ")(?![\\w])", "g");
            name_rep = "<span class='hyellow'>" + pc + "</span>";
            html_text = html_text.replace(name_reg, name_rep);
        }

        update_hotkeys();

        $('#page_text').empty;
        $('#page_text').html(html_text.trim());
    }

    function add_to_hot_names(name) {
        var in_hot_names = false;
        for (let value of hot_names.values()) {
            if (value[0] === name) {
                value[1] = 0;
                in_hot_names = true;
                break;
            }
        }
        if (!in_hot_names) {
            var high_val = 0;
            var high_key = null;
            for (let key of hot_names.keys()) {
                if (hot_names.get(key)[0] == "") {
                    high_key = key;
                    break;
                } else if (hot_names.get(key)[1] > high_val) {
                    high_key = key;
                    high_val = hot_names.get(key)[1];
                }
            }
            if (high_key != null) {
                hot_names.set(high_key, [name, 0]);
            } else {
                log("ERROR: Too many fresh names, no countermeasure yet");
            }
        }
    }

    function select_quote(quote) {
        var classes = quote.classList;
        $('.quote_div').removeClass("selected");
        $(quote).addClass("selected");
        if (classes.contains("assigned")) {
            $(quote).removeClass("assigned");
            //this nonsense works for now, but I should extract quote text somewhere/somehow else i think
            var quote_text = quote.textContent;
            var quote_reg = new RegExp("\".*\"", "s");
            var quote_matches = quote_text.match(quote_reg);
            if (quote_matches != null) {
                quote.textContent = quote_matches[0];
            }
        }
    }

    function add_name() {
        //There's a bug here where if the user cancels the prompt, it prevents other hotkeys from functioning
        //ignoring for now
        var alias = prompt("Enter new name:", "");
        if (alias === null) {
            log("ERROR: null prompt - need to refresh for hotkey functionality");
            return;
        }
        if (alias == "") {
            log("No Prompt Entry");
        } else {
            add_to_array(known_names, alias);
            add_to_hot_names(alias);
            process_page_text();
        }
    }

    function add_to_map(list, term, count=1) {
        for (let key of list.keys()) {
            if (key == term) {
                list.set(key, list.get(key) + count);
                return;
            }
        }
        list.set(term, count);
    }

    function add_to_array(list, term) {
        if (!list.includes(term)) {
            list.push(term);
        }
    }

    function get_val(element, clear=false) {
        var el = $('#' + element);
        if (el.length === 0) {
            log("ERROR: failed to find element id: " + element);
            return null;
        }
        var ret = el.val();
        if (clear) {
            el.val("");
        }
        return ret;
    }

    function set_val(element, new_val, clear = true) {
        var el = $('#' + element);
        if (el.length === 0) {
            log("ERROR: failed to find element id: " + element);
            return false;
        }
        if (clear) {
            el.val(String(new_val));
        } else {
            el.val(el.val() + new_val);
        }
        return true;
    }

    function set_quote(args) {
        var all_quotes = document.getElementsByClassName('quote_div');
        var quote_div = null;
        var speaker = args[0];
        for (var i = 0, len = all_quotes.length | 0; i < len; i = i + 1) {
            quote_div = all_quotes[i];
            if (quote_div.classList.contains("selected")) {
                var quote_text = quote_div.textContent;
                add_to_map(page_quotes, speaker, quote_text.split(/\s+(?!$)/).length);
                quote_div.setAttribute("class", "quote_div assigned");
                quote_div.innerHTML = quote_div.innerHTML + "<br /><br />Assigned: " + speaker;
                if (i + 1 < len) {
                    all_quotes[i+1].setAttribute("class", "quote_div selected");
                }
                break;
            }
        }
    }

    function mark_scene() {
        //log("Called mark_scene");
        var next_words = prompt("Enter first words of next scene:", "");
        if (next_words === null) {
            log("ERROR: null prompt - need to refresh for hotkey functionality");
            return;
        }
        if (next_words === "") {
            log("No Prompt Entry");
        } else {
            var endpoint = page_text.indexOf(next_words);
            if (endpoint >= 0) {
                //log("Setting scene end at: " + next_words + " : " + endpoint);
                scene_end = endpoint;
                abs_char_count = page_start;
                last_page = true;
                next_page();
                last_page = false;
            }
        }
    }

    function generate_summary() {
        //checking and updating last page
        if (!save_page_to_scene()) {
            log("ERROR: Quotes unassigned");
            return;
        }
        //checking form fields
        var checked_fields = true;
        checked_fields = get_val('chapter_box') != "" & checked_fields;
        checked_fields = get_val('primary_box') != "" & checked_fields;
        checked_fields = get_val('locations_box') != "" & checked_fields;
        checked_fields = get_val('description_box') != "" & checked_fields;
        if (!checked_fields) {
            log("ERROR: Scene fields empty");
            return;
        }

        //transferring data to gen_form
        set_val('known_names', known_names.join());
        set_val('position', page_start);
        set_val('chapter', get_val('chapter_box'));
        set_val('primary', get_val('primary_box'));
        set_val('locations', get_val('locations_box'));
        set_val('description', get_val('description_box'));
        set_val('wordcount', scene_wordcount);
        var sm_string = "";
        for (let [key, value] of scene_mentions.entries()) {
            sm_string = sm_string + key + "," + value + "\n";
        }
        sm_string = sm_string.trim();
        set_val('mentions', sm_string);
        var sq_string = "";
        for (let [key, value] of scene_quotes.entries()) {
            sq_string = sq_string + key + "," + value + "\n";
        }
        sq_string = sq_string.trim();
        set_val('quotes', sq_string);
        var ce_string = "";
        for (let ce of char_events) {
            ce_string = ce_string + [ce[0], ce[1].join(), ce[2].join(), ce[3].join()].join(";") + "\n";
        }
        ce_string = ce_string.trim();
        set_val('char_events', ce_string);

        //log_report
        log("Current Summary:", true);
        log("Known Names: " + get_val('known_names'));
        log("Char Position: " + get_val('position'));
        log("Chapter Name: " + get_val('chapter'));
        log("Primary Character: " + get_val('primary'));
        log("Locations: " + get_val('locations').replace(/[\v\r\n]+/g, ","));
        log("Brief Description: " + get_val('description'));
        log("");
        log("Scene Words: " + get_val('wordcount'));
        log("Scene Mentions:");
        log(get_val('mentions'));
        log("Scene Quote-Words:");
        log(get_val('quotes'));
        log("Character Events:");
        log(get_val('char_events'));

        //diagnostic();
        if (confirm("Submit Form?")) { $("#gen_form").submit(); }  
    }

    function diagnostic() {
        log("***");
        log("Diagnostic:");
        log("***");
    }
</script>