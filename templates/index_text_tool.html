<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Threads of the Pattern</title>
</head>

<body onload="init('{{book_file}}', {{position}})">
    <h2>Interactive Text Parser</h2>
    <!--  
        This is admittedly an ugly fix to our problem of interfacing between the page and python.
        We use a hidden form with fields corresponding to the data to be saved.
        The corresponding function populates the fields and submits the form.
        On the python side, we use request.form to pull the data into the database, perform server-side
        operations, then re-upload the data to preserve the context.
        Options for elegant asynchronous data-transfer with AJAX may come, but it's essential for now that
        we begin building the database so we can create initial data models.
    -->
    <form hidden id="gen_form" action="/generate_summary" method="post">
        <textarea id="known_names">{{known_names}}</textarea>
        <input type="text" name="position"/>
    </form>
    <div id="main_div">
        <div id="page_div">
            <pre id="page_text"></pre>
            <div id="page_quotes"></div>
        </div>
        <div id="utils_div">
            <div id="inputs_div">
                <div id="scene_div">
                    Scene Info:<br /><br />
                    <label for="chapter_box">Chapter Name:</label>
                    <input type="text" name="chapter_box"><br />
                    <label for="primary_box">Primary Character Name:</label>
                    <input type="text" name="primary_box"><br />
                    <label for="locations_box">Location Names:</label>
                    <textarea name="locations_box"></textarea><br />
                    <label for="summary_box">Brief Description:</label>
                    <textarea name="summary_box"></textarea><br />
                </div>
                <div id="char_div">
                    Character Update:<br /><br />
                    <label for="char_name_box">Character Name:</label>
                    <input type="text" id="char_name_box" name="char_name_box" /><br />
                    <label for="aliases_box">New Aliases:</label>
                    <textarea id="aliases_box" name="aliases_box"></textarea><br />
                    <label for="joins_box">Joined Characters:</label>
                    <textarea id="joins_box" name="joins_box"></textarea><br />
                    <label for="tags_box">New Tags:</label>
                    <textarea id="tags_box" name="tags_box"></textarea><br />
                </div>
            </div>
            <div id="buttons_div">
                <button id="next_page_button" class="button dark">Next Page</button>
                <button id="event_button" class="button dark">Char Event</button>
                <button id="add_button" class="button dark">Add Name</button>
                <button id="quote_button" class="button dark">Set Quote</button>
                <button id="reset_button" class="button dark">Reset</button>
                <button id="summary_button" class="button dark">Sum</button>
                <button id="mark_button" class="button dark">Mark Scene</button>
                <button id="save_button" class="button dark">Save Scene</button>
            </div>
            <div id="hotkeys_log_div">
                <div id="hotkeys">
                    <div id="fixed_hotkeys"></div>
                    <div id="char_hotkeys"></div>
                </div>
                <div id="log">
                    Log Output:
                    <textarea id="log_box" readonly></textarea>
                </div>
            </div>
        </div>
    </div>
</body>
</html>

<style>
    * {
        font-family: Calibri;
    }
    *:focus {
        outline: none;
    }

    div {
        position: relative;
        top: 0px;
        left: 0px;
        display: flex;
        align-items: flex-start;
        border-radius: 5px;
        border: 1px solid hsl(240, 100%, 25%);
        color: black;
        height: 100%;
        width: 100%;
        flex-direction: row;
    }
    #main_div {
        height: 700px;
    }
    #page_div {
        width: 50%;
        flex-direction: column;
    }
    #utils_div {
        width: 50%;
        flex-direction: column;
    }
    #page_text {
        height: 50%;
    }
    #page_quotes {
        height: 50%;
        flex-direction: column;
    }
    #inputs_div {
        height: 50%;
    }
    #scene_div {
        flex-direction: column;
    }
    #char_div {
        flex-direction: column;
    }
    #buttons_div {
        height: 10%;
    }
    #hotkeys_log_div {
        height: 40%;
    }
    #hotkeys {
        width: 50%;
    }
    #fixed_hotkeys {
        flex-direction: column;
    }
    #char_hotkeys {
        flex-direction: column;
    }
    #log {
        width: 50%;
        flex-direction: column;
    }

    #log_box {
        width: 100%;
        height: 100%;
        overflow: hidden;
        resize: none;
        overflow-y: scroll;
        font-family: 'Lucida Console';
    }

    .button {
        height: 50px;
        width: 50px;
        border-radius: 8px;
        font-size: 12px;
        text-align: center;
        text-decoration: none;
        transition-duration: 0.2s;
        border: 1px solid hsl(240, 100%, 25%);
    }
    .button:hover {
        border: 1px solid white;
    }
    .button:active {
        background-color: hsl(240, 100%, 75%);
    }

    .light {
        background-color: hsl(240, 100%, 90%);
        color: hsl(240, 100%, 25%);
    }
    .dark {
        background-color: hsl(240, 100%, 25%);
        color: white;
    }

    .hgreen {
        background-color:  lime;
    }
    .hyellow {
        background-color: yellow;
    }

    .selected {
        background-color: yellow;
    }
    .assigned {
        background-color: lime;
    }

</style>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
<script>
    //page utilities
    var active_hotkeys = new Map();
    var input_focus = false;

    var full_text = "";
    var abs_char_count = 0;
    var abs_word_count = 0;
    
    var page_text = "";
    var page_mentions = new Map();
    var page_quotes = new Map();

    //scene data storage (will be saved via form)
    var scene_mentions = new Map();
    var scene_quotes = new Map();
    var char_events = new Map();
    
    var known_names = [];
    var hot_names = new Map();

    $(document).ready(function () {
        $(document).keypress(hotkey);
        $("input").focus(function () {
            input_focus = true;
        });
        $("input").blur(function () {
            input_focus = false;
        });
        $("textarea").focus(function () {
            input_focus = true;
        });
        $("textarea").blur(function () {
            input_focus = false;
        });
        $('#next_page_button').click(next_page);
        $('#add_button').click(add_name);
        $('#summary_button').click(generate_summary);
        $('#event_button').click(character_event);
    });

    function init(book_file, position) {
        active_hotkeys.set(110, ["next_page", []]); //n
        active_hotkeys.set(97, ["add_name", []]); //a
        active_hotkeys.set(115, ["generate_summary", []]); //s
        active_hotkeys.set(99, ["character_event", []]); //c

        $.get(book_file, read_text);
        abs_char_count = position;
        known_names = $('#known_names').text().split(',');
        for (var i = 0; i < 10; i++) {
            hot_names.set(i, ["", 0]);
        }

        $('#log_box').text("Log output will appear here:");
        $('#page_text').text("Page text will appear here:");
        $('#page_quotes').text("Page quotes will appear here:");
        $('#fixed_hotkeys').html("<b>Fixed Hotkeys:</b>" +
            "Next Page: N<br />" +
            "Add Character: A<br />");
        $('#char_hotkeys').html("<b>Character Hotkeys:</b>");
        //this would be a small qol, but it's crashing the page (running before fully initialized?)
        //TODO
        //next_page();
    }

    function log(string, clear = false) {
        if (clear) {
            $('#log_box').text("");
        }
        $('#log_box').text($('#log_box').text() + "\n" + string);
    }

    function read_text(data, status) {
        if (status == "success") {
            full_text = data;
        } else {
            full_text = "Unexpected error reading text file";
        }
    }

    function hotkey(key) {
        //log(key.which);
        if (active_hotkeys.has(key.which) && input_focus == false) {
            func = String(active_hotkeys.get(key.which)[0]);
            args = active_hotkeys.get(key.which)[1];
            window[func](args);
        }
    }

    function next_page() {
        //checking that all previous quotes are assigned
        var checked_quotes = true;
        var all_quotes = document.getElementsByClassName('quote_div');
        for (var i = 0, len = all_quotes.length | 0; i < len; i = i + 1) {
            var quote_div = all_quotes[i];
            if (!quote_div.classList.contains("assigned")) {
                checked_quotes = false;
                break;
            }
        }
        if (!checked_quotes) {
            log("ERROR: Cannot start new page until all quotes on previous page are assigned");
            return;
        }

        //storing previous page mentions, quotes in scene arrays
        for (let key of page_mentions.keys()) {
            add_to_map(scene_mentions, key, page_mentions.get(key));
        }
        for (let key of page_quotes.keys()) {
            add_to_map(scene_quotes, key, page_quotes.get(key));
        }

        log("New Page");
        log("Abs Pos: " + abs_char_count);

        page_quotes.clear();
        var quotes = [];
        var lines = 0;
        var char_inc = 0;
        var in_quote = false;
        var quote_start = 0;
        while ((quotes.length < 5 && lines < 17) || in_quote) {
            next_char = full_text.charAt(abs_char_count + char_inc++);
            if (next_char == "\n") {
                lines++;
            }
            if (next_char == "\"") {
                if (!in_quote) {
                    in_quote = true;
                    quote_start = abs_char_count + char_inc;
                } else {
                    in_quote = false;
                    var quote = full_text.substring(quote_start, abs_char_count + char_inc - 1);
                    quote.replace("\n", " ");
                    quotes.push(quote);
                }
            }
        }
        $('#page_quotes').empty();
        for (let q of quotes) {
            var quote_html = "<div onclick='select_quote(this)' class='quote_div'>\"" + String(q) + "\"</div>";
            $('#page_quotes').append(quote_html);
        }
        $(".quote_div:first").addClass('selected');

        page_text = full_text.substr(abs_char_count, char_inc);
        process_page_text();

        update_hotkeys(true);

        abs_word_count += page_text.split(/[\s-."]+/).length;
        abs_char_count += char_inc;
    }

    function character_event() {
        log("cnb: " + get_text('char_name_box'));
        log("ab: " + get_text('aliases_box'));
        log("jb: " + get_text('joins_box'));
        log("tb: " + get_text('tags_box'));
    }

    function update_hotkeys(inc_hot_names=false) {
        var char_hotkey_text = "<b>Character Hotkeys:</b>";
        for (let key of hot_names.keys()) {
            var name_val = hot_names.get(key)[0];
            if (name_val != "") {
                active_hotkeys.set(48 + key, ["set_quote", [name_val]]); //48 is key 0
                char_hotkey_text += name_val + ": " + key + "<br />";
                if (inc_hot_names) {hot_names.set(key, [name_val, hot_names.get(key)[1] + 1]);}
            }
        }
        $('#char_hotkeys').html(char_hotkey_text);
    }

    function process_page_text() {
        page_mentions.clear();
        var html_text = page_text;
        var page_words = page_text.split(/[\s-."]+/);
        var potential_matches = known_names;
        var potential_name = "";
        var best_matches = [];
        var page_caps = new Map();
        //can maybe be refactored now that i can use break
        for (let p of page_words) {
            if (potential_name != "") {
                potential_name += " " + /^"*(['A-Za-z]*)/.exec(p)[1];
            } else if (/^"*([A-Z].*)/.test(p)) {
                potential_name = /^"*(['A-Za-z]*)/.exec(p)[1];
            }
            if (potential_name != "") {
                //log("pm: " + potential_name);
                potential_name = potential_name.replace("'s", "");
                var pm_reg = new RegExp(potential_name + "(\\s*$|\\s+)");
                potential_matches = potential_matches.filter(pm => pm.search(pm_reg) >= 0);
                if (potential_matches.length > 0) {
                    best_matches = potential_matches.filter(pm => pm == potential_name);
                } else {
                    if (best_matches.length > 0) {
                        add_to_map(page_mentions, best_matches[0]);
                        best_matches = [];
                        potential_matches = known_names;
                    } else {
                        add_to_map(page_caps, potential_name);
                        potential_name = "";
                        potential_matches = known_names;
                    }
                    if (/^"*([A-Z].*)/.test(p)) {
                        potential_name = /^"*(['A-Za-z]*)/.exec(p)[1];
                        potential_name = potential_name.replace("'s", "");
                        pm_reg = new RegExp(potential_name + "(\\s*$|\\s+)");
                        potential_matches = potential_matches.filter(pm => pm.search(pm_reg) >= 0);
                        if (potential_matches.length > 0) {
                            best_matches = potential_matches.filter(pm => pm == potential_name);
                        }
                    } else {
                        potential_name = "";
                    }
                }
            }
        }
        var name_reg = null;
        var name_rep = "";
        for (let pm of page_mentions.keys()) {
            name_reg = new RegExp("(?<!>)(" + pm + ")(?![<\\w])", "g");
            name_rep = "<span class='hgreen'>" + pm + "</span>";
            html_text = html_text.replace(name_reg, name_rep);

            add_to_hot_names(pm);
        }
        for (let pc of page_caps.keys()) {
            name_reg = new RegExp("(?<!>)(" + pc + ")(?![\\w])", "g");
            name_rep = "<span class='hyellow'>" + pc + "</span>";
            html_text = html_text.replace(name_reg, name_rep);
        }

        $('#page_text').empty;
        $('#page_text').html(html_text.trim());
    }

    function add_to_hot_names(name) {
        var in_hot_names = false;
        for (let value of hot_names.values()) {
            if (value[0] === name) {
                value[1] = 0;
                in_hot_names = true;
                break;
            }
        }
        if (!in_hot_names) {
            var high_val = 0;
            var high_key = null;
            for (let key of hot_names.keys()) {
                if (hot_names.get(key)[0] == "") {
                    high_key = key;
                    break;
                } else if (hot_names.get(key)[1] > high_val) {
                    high_key = key;
                    high_val = hot_names.get(key)[1];
                }
            }
            if (high_key != null) {
                hot_names.set(high_key, [name, 0]);
            } else {
                log("ERROR: Too many fresh names, no countermeasure yet");
            }
        }
    }

    function select_quote(quote) {
        var classes = quote.classList;
        $('.quote_div').removeClass("selected");
        $(quote).addClass("selected");
        if (classes.contains("assigned")) {
            $(quote).removeClass("assigned");
            //this nonsense works for now, but I should extract quote text somewhere/somehow else i think
            var quote_text = quote.textContent;
            var quote_reg = new RegExp("\".*\"", "s");
            var quote_matches = quote_text.match(quote_reg);
            if (quote_matches != null) {
                quote.textContent = quote_matches[0];
            }
        }
    }

    function add_name() {
        //There's a bug here where if the user cancels the prompt, it prevents other hotkeys from functioning
        //ignoring for now
        var alias = prompt("Enter new name:", "");
        if (alias === null) {
            log("ERROR: added name is null - need to refresh");
            return;
        }
        if (alias == "") {
            log("Blank name");
        } else {
            add_to_array(known_names, alias);
            add_to_hot_names(alias);
            update_hotkeys();
            process_page_text();
        }
    }

    function add_to_map(list, term, count=1) {
        for (let key of list.keys()) {
            if (key == term) {
                list.set(key, list.get(key) + count);
                return;
            }
        }
        list.set(term, count);
    }

    function add_to_array(list, term) {
        if (!list.includes(term)) {
            list.push(term);
        }
    }

    function get_text(element) {
        var el = $('#' + element);
        if (el.length === 0) {
            log("ERROR: failed to find element id: " + element);
            return null;
        }
        return el.val();
    }

    function set_quote(args) {
        var all_quotes = document.getElementsByClassName('quote_div');
        var quote_div = null;
        var speaker = args[0];
        for (var i = 0, len = all_quotes.length | 0; i < len; i = i + 1) {
            quote_div = all_quotes[i];
            if (quote_div.classList.contains("selected")) {
                var quote_text = quote_div.textContent;
                add_to_map(page_quotes, speaker, quote_text.split(" ").length);
                quote_div.setAttribute("class", "quote_div assigned");
                quote_div.innerHTML = quote_div.innerHTML + "<br /><br />Assigned: " + speaker;
                if (i + 1 < len) {
                    all_quotes[i+1].setAttribute("class", "quote_div selected");
                }
                break;
            }
        }
    }

    function generate_summary() {
        log("Current Summary", true);
        log("Scene Mentions:");
        for (let key of scene_mentions.keys()) {
            log("  " + key + ": " + scene_mentions.get(key));
        }
        log("Scene Quote-Words:");
        for (let key of scene_quotes.keys()) {
            log("  " + key + ": " + scene_quotes.get(key));
        }
        //$("#gen_form").submit();
    }
</script>