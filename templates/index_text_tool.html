<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Threads of the Pattern</title>
</head>

<body onload="init()">
    <div id="main_div">
        <div id="page_report_div">
            <div id="page_div">
                <pre id="page_text"></pre>
                <div id="page_quotes"></div>
            </div>
            <div id="report_div">
                <pre id="report_text">{{report}}</pre>
            </div>
        </div>
        <div id="utils_gen_div">
            <div id="utils_div">
                <div id="hotkeys_log_div">
                    <div id="hotkeys">
                        <div id="buttons_div">
                            <button id="next_page_button" class="button">Next Page (N)</button>
                            <button id="event_button" class="button">Char Event (C)</button>
                            <button id="add_button" class="button">Add Name (A)</button>
                            <button id="summary_button" class="button">Generate Summary (G)</button>
                            <button id="mark_button" class="button">Mark Scene End (M)</button>
                            <button id="save_button" class="button">Save Scene (S)</button>
                            <button id="diagnostic_button" class="button">Diagnostic (D)</button>
                            <button id="translate_button" class="button">Translate Summary (T)</button>
                        </div>
                        <div id="char_hotkeys"></div>
                    </div>
                    <div id="log_div">
                        Log Output:
                        <textarea id="log_box" readonly></textarea>
                    </div>
                </div>
                <div id="inputs_div">
                    <div id="scene_div">
                        Scene Info:<br /><br />
                        <label for="chapter_box">Chapter Name:</label>
                        <input type="text" id="chapter_box" name="chapter_box"><br />
                        <label for="primary_box">Primary Character Name:</label>
                        <input type="text" id="primary_box" name="primary_box"><br />
                        <label for="locations_box">Location Names:</label>
                        <textarea id="locations_box" name="locations_box">TODO</textarea><br />
                        <label for="description_box">Brief Description:</label>
                        <textarea id="description_box" name="description_box"></textarea><br />
                        <label for="features_box">Featuring:</label>
                        <textarea id="features_box" name="features_box"></textarea><br />
                    </div>
                    <div id="char_div">
                        Character Update:<br /><br />
                        <label for="char_name_box">Character Name:</label>
                        <input type="text" id="char_name_box" name="char_name_box" /><br />
                        <label for="aliases_box">New Aliases:</label>
                        <textarea id="aliases_box" name="aliases_box"></textarea><br />
                        <label for="joins_box">Joined Characters:</label>
                        <textarea id="joins_box" name="joins_box"></textarea><br />
                        <label for="tags_box">New Tags:</label>
                        <textarea id="tags_box" name="tags_box"></textarea><br />
                    </div>
                </div>
            </div>
            <div id="gen_div">
                <form id="gen_form" action="/generate_summary" method="post">
                    Raw Data:<br />
                    <label for="save_status">Save Status:</label>
                    <input readonly type="text" id="save_status" name="ss_form" value="{{save_status}}" /><br />
                    <label for="save_file">Save File:</label>
                    <input type="text" id="save_file" name="sf_form" value="{{save_file}}"><br />
                    <label for="book_file">Book File:</label>
                    <input type="text" id="book_file" name="bf_form" value="{{book_file}}"><br />
                    <label for="position">Position:</label>
                    <input type="text" id="position" name="po_form" value="{{position}}"><br />
                    <label for="chapter">Chapter:</label>
                    <input type="text" id="chapter" name="ch_form" value="{{chapter}}"><br />
                    <label for="primary">Primary:</label>
                    <input type="text" id="primary" name="pr_form" value="{{primary}}"><br />
                    <label for="wordcount">Wordcount:</label>
                    <input type="text" id="wordcount" name="wo_form" value="{{wordcount}}"><br />
                    <label for="locations">Locations:</label>
                    <textarea id="locations" name="lo_form">TODO</textarea><br />
                    <label for="description">Description:</label>
                    <textarea id="description" name="de_form">{{description}}</textarea><br />
                    <label for="mentions">Mentions:</label>
                    <textarea id="mentions" name="me_form">{{mentions}}</textarea><br />
                    <label for="quotes">Quotes:</label>
                    <textarea id="quotes" name="qu_form">{{quotes}}</textarea><br />
                    <label for="features">Features:</label>
                    <textarea id="features" name="fe_form">{{features}}</textarea><br />
                    <label for="char_events">Char Events:</label>
                    <textarea id="char_events" name="ce_form">{{char_events}}</textarea><br />
                    <label for="known_names">Known Names:</label>
                    <textarea id="known_names" name="kn_form">{{known_names}}</textarea><br />
                    <label for="log">Log:</label>
                    <textarea id="log" name="lg_form">{{log}}</textarea><br />
                </form>
            </div>
        </div>
    </div>
</body>
</html>

<style>
    * {
        font-family: Calibri;
        background-color: lightgrey;
        color: black;
    }

    *:focus {
        outline: none;
    }

    pre {
        white-space: pre-line;
        word-wrap: normal;
    }

    div {
        position: relative;
        top: 0px;
        left: 0px;
        display: flex;
        align-items: flex-start;
        /*border-radius: 5px;*/
        border: 1px solid white;
        width: 100%;
        flex-direction: row;
    }
    #page_report_div {
        width: 50%;
        flex-direction: column;
    }
    #page_div {
        min-height: 750px;
        flex-direction: column;
    }
    #utils_gen_div {
        width: 50%;
        flex-direction: column;
    }
    #page_text {
        min-height: 150px;
    }
    #page_quotes {
        min-height: 150px;
        flex-direction: column;
    }
    #utils_div {
        flex-direction: column;
    }
    #inputs_div {
        min-height: 50%;
    }
    #scene_div {
        width: 50%;
        flex-direction: column;
    }
    #char_div {
        flex-direction: column;
    }
    #hotkeys {
        width: 50%;
    }
    #buttons_div {
        flex-direction: column;
    }
    #char_hotkeys {
        flex-direction: column;
    }
    #log_div {
        width: 50%;
        flex-direction: column;
    }
    #log_box {
        min-height: 350px;
        width: 97%;
        overflow: hidden;
        resize: none;
        overflow-y: scroll;
        overflow-x: scroll;
        font-family: 'Lucida Console';
    }
    #gen_div {
        flex-direction: column;
    }

    .button {
        height: 40px;
        width: 100px;
        font-size: 12px;
        text-align: center;
        text-decoration: none;
        transition-duration: 0.2s;
        border: 1px solid white;
        background-color: lightgrey;
        color: black;
    }
    .button:hover {
        background-color: grey;
    }
    .button:active {
        background-color: dimgrey;
    }
    .hgreen {
        background-color: lime;
    }
    .hyellow {
        background-color: yellow;
    }
    .hred {
        background-color: palevioletred;
    }
    .quote_div {
        min-height: 50px;
    }
    .selected {
        background-color: yellow;
    }
    .assigned {
        background-color: lime;
    }
    input {
        border: groove;
    }
</style>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
<script>
    //imports
    //import {default as get_val, set_val, add_to_array, add_to_map} from "./util"

    //page utilities
    var active_hotkeys = new Map();
    var input_focus = false;
    var last_page = false;

    var full_text = "";
    var abs_char_count = 0;

    var page_start = 0;
    var page_text = "";
    var page_wordcount = 0;
    var page_mentions = new Map();
    var page_quotes = new Map();

    //scene data storage (will be saved via form)
    var scene_wordcount = 0;
    var scene_mentions = new Map();
    var scene_quotes = new Map();
    var scene_features = [];
    var char_events = [];
    var scene_end = null;

    var known_names = [];
    var hot_names = new Map();

    function init() {
        $(document).keypress(hotkey);
        $("input").focus(function () {
            input_focus = true;
        });
        $("input").blur(function () {
            input_focus = false;
        });
        $("textarea").focus(function () {
            input_focus = true;
        });
        $("textarea").blur(function () {
            input_focus = false;
        });
        $('#next_page_button').click(next_page);
        $('#add_button').click(add_name);
        $('#summary_button').click(generate_summary);
        $('#event_button').click(character_event);
        $('#mark_button').click(mark_scene);
        $('#diagnostic_button').click(diagnostic);
        $('#translate_button').click(translate_summary);
        $('#save_button').click(save_scene);

        active_hotkeys.set(110, ["next_page", []]); //n
        active_hotkeys.set(97, ["add_name", []]); //a
        active_hotkeys.set(103, ["generate_summary", []]); //g
        active_hotkeys.set(115, ["save_scene", []]); //s
        active_hotkeys.set(99, ["character_event", []]); //c
        active_hotkeys.set(109, ["mark_scene", []]); //m
        active_hotkeys.set(100, ["diagnostic", []]); //d
        active_hotkeys.set(116, ["translate_summary", []]); //t

        $.get(get_val('book_file'), read_text);
        for (var i = 0; i < 10; i++) {
            hot_names.set(i, ["", 0]);
        }
        if (get_val("save_status") == "") {
            set_val("save_status", "saved");
        } else if (get_val("save_status") == "reviewing") {
            $('#page_div').hide();
        }

        $('#page_text').text("Page text will appear here:");
        $('#page_quotes').text("Page quotes will appear here:");
        $('#char_hotkeys').html("<b>Character Hotkeys:</b>");

        if (get_val("save_status") == "saved") {
            $('#report_text').html("");
        } else {
            $('#report_text').html($('#report_text').text());
        }

        translate_summary();
    }

    function add_to_map(list, term, count = 1) {
        for (let key of list.keys()) {
            if (key == term) {
                list.set(key, list.get(key) + count);
                return;
            }
        }
        list.set(term, count);
    }

    function add_to_array(list, term) {
        if (!list.includes(term)) {
            list.push(term);
        }
    }

    function get_val(element, clear = false) {
        var el = $('#' + element);
        if (el.length === 0) {
            log("ERROR: failed to find element id: " + element);
            return null;
        }
        var ret = el.val();
        if (clear) {
            el.val("");
        }
        return ret;
    }

    function set_val(element, new_val, clear = true) {
        var el = $('#' + element);
        if (el.length === 0) {
            return false;
        }
        if (clear) {
            el.val(String(new_val));
        } else {
            el.val(el.val() + new_val);
        }
        return true;
    }

    function log(string, clear = false) {
        if (clear) {
            set_val('log_box', "");
        }
        set_val('log_box', get_val('log_box') + "\n" + string);
    }

    function diagnostic() {
        if (confirm("Also Clear Log?")) {
            log("Cleared log", true);
        }
        log("***");
        log("Diagnostic:");
        log("***");
        log("Stored Features:")
        for (let f of scene_features) {
            log(f);
        }
        /*log("Known Names: ");
        for (let k of known_names) {
            log(k);
        }*/
    }

    function read_text(data, status) {
        if (status == "success") {
            full_text = data;
        } else {
            full_text = "Unexpected error reading text file";
        }
    }

    function hotkey(key) {
        //log(key.which);
        if (active_hotkeys.has(key.which) && input_focus == false) {
            func = String(active_hotkeys.get(key.which)[0]);
            args = active_hotkeys.get(key.which)[1];
            window[func](args);
        }
    }

    function save_page_to_scene() {
        //checking that all previous quotes are assigned
        var checked_quotes = true;
        var all_quotes = document.getElementsByClassName('quote_div');
        for (var i = 0, len = all_quotes.length | 0; i < len; i = i + 1) {
            var quote_div = all_quotes[i];
            if (!quote_div.classList.contains("assigned")) {
                checked_quotes = false;
                break;
            }
        }
        if (!checked_quotes) {
            return false;
        }
        //adding previous page info to scene_arrays
        for (let key of page_mentions.keys()) {
            add_to_map(scene_mentions, key, page_mentions.get(key));
        }
        for (let key of page_quotes.keys()) {
            add_to_map(scene_quotes, key, page_quotes.get(key));
            add_to_array(scene_features, key);
        }
        set_val('features_box', scene_features.join("\n"));
        scene_wordcount += page_wordcount;
        page_start = abs_char_count;
        return true;
    }

    function next_page() {
        var save_status = get_val('save_status');
        if (save_status == "saved") {
            set_val('save_status', "parsing");
        } else if (save_status == "reviewing") {
            log("ERROR: cannot continue until previous scene is saved");
            return;
        }
        if (!last_page) {
            if (!save_page_to_scene()) {
                log("ERROR: Cannot start until all quotes on previous page are assigned");
                return;
            }
        }

        page_quotes.clear();
        var quotes = [];
        var char_inc = 0;
        var in_quote = false;
        var in_word = false;
        var quote_start = 0;
        while ((quotes.length < 5 && char_inc < 2000) || in_quote || !in_word) {
            next_char = full_text.charAt(abs_char_count + char_inc++);
            in_word = /\s/.test(next_char);
            if (next_char == "\"") {
                if (!in_quote) {
                    in_quote = true;
                    quote_start = abs_char_count + char_inc;
                } else {
                    in_quote = false;
                    var quote = full_text.substring(quote_start, abs_char_count + char_inc - 1);
                    quote.replace("\n", " ");
                    quotes.push(quote);
                }
            }
            if (scene_end !== null && char_inc >= scene_end) {
                break;
            }
        }
        $('#page_quotes').empty();
        for (let q of quotes) {
            var quote_html = "<div onclick='select_quote(this)' class='quote_div'>\"" + String(q) + "\"</div>";
            $('#page_quotes').append(quote_html);
        }
        $(".quote_div:first").addClass('selected');

        page_text = full_text.substr(abs_char_count, char_inc);

        process_page_text();
        update_hotkeys();
        if (!last_page) {
            for (let [key, value] of hot_names.entries()) {
                hot_names.set(key, [value[0], value[1] + 1]);
            }
        }

        abs_char_count += char_inc;
    }

    function character_event() {
        var char_name = get_val('char_name_box');
        if (char_name == "") {
            log("ERROR: Character Events must have a primary name.");
            return;
        } else {
            add_to_array(known_names, char_name);
            add_to_hot_names(char_name);
        }
        var char_aliases = smart_split(get_val('aliases_box'), "[\\v\\r\\n]+");
        for (ca of char_aliases) {
            add_to_array(known_names, ca);
            add_to_hot_names(ca);
        }
        process_page_text();
        add_to_array(char_events, [
            get_val('char_name_box', true),
            smart_split(get_val('aliases_box', true), "[\\v\\r\\n]+"),
            smart_split(get_val('joins_box', true), "[\\v\\r\\n]+"),
            smart_split(get_val('tags_box', true), "[\\v\\r\\n]+")
        ]);
        log("Submitted Character Event for: " + char_name);
    }

    function update_hotkeys() {
        var char_hotkey_text = "<b>Character Hotkeys:</b>";
        for (let [key, value] of hot_names.entries()) {
            var name_val = value[0];
            if (name_val != "") {
                active_hotkeys.set(48 + key, ["set_quote", [name_val]]); //48 is the 0 key, 49->1, etc 
                char_hotkey_text += name_val + ": " + key + "<br />";
            }
        }
        $('#char_hotkeys').html(char_hotkey_text);
    }

    function process_page_text() {
        var html_text = page_text;
        var potential_matches = known_names;
        var potential_name = "";
        var best_matches = [];
        var page_caps = new Map();

        page_mentions.clear();
        page_quotes.clear();

        //characters in this regex are ones that may be contained within the whitespace of a word but shouldn't be included
        var page_words = smart_split(page_text, "[\\s\"\\-]+");
        page_wordcount = page_words.length;
        if (page_wordcount == 0) {
            return;
        }

        //can maybe be refactored now that i can use break
        for (let p of page_words) {
            //log("p: " + p);
            if (potential_name != "") {
                potential_name += " " + /^"*(['A-Za-z]*[\.,]?)/.exec(p)[1];
            } else if (/^"*([A-Z].*)/.test(p)) {
                potential_name = /^"*(['A-Za-z]*[\.,]?)/.exec(p)[1];
            }
            if (potential_name != "") {
                //log("pot_name: " + potential_name);
                var pm_reg = new RegExp("^" + potential_name.replace(/'s/g, "").replace(/\./g, "\\.?").replace(/,/g, ",?") + "(\\s*$|\\s+)");
                potential_matches = potential_matches.filter(pm => pm.search(pm_reg) >= 0);
                if (potential_matches.length > 0) {
                    pm_reg = new RegExp("^" + potential_name.replace(/'s/g, "").replace(/\./g, "\\.?").replace(/,/g, ",?") + "\\s*$");
                    best_matches = potential_matches.filter(pm => pm.search(pm_reg) >= 0);
                } else {
                    if (best_matches.length > 0) {
                        //log("best_matches: " + best_matches);
                        add_to_map(page_mentions, best_matches[0]);
                        best_matches = [];
                        potential_matches = known_names;
                    } else {
                        potential_name = smart_split(potential_name, "\\s+")[0];
                        add_to_map(page_caps, potential_name);
                        potential_name = "";
                        potential_matches = known_names;
                    }
                    if (/^"*([A-Z].*)/.test(p)) {
                        potential_name = /^"*(['A-Za-z]*[\.,]?)/.exec(p)[1];
                        pm_reg = new RegExp("^" + potential_name.replace(/'s/g, "").replace(/\./g, "\\.?").replace(/,/g, ",?") + "(\\s*$|\\s+)");
                        potential_matches = potential_matches.filter(pm => pm.search(pm_reg) >= 0);
                        if (potential_matches.length > 0) {
                            pm_reg = new RegExp("^" + potential_name.replace(/'s/g, "").replace(/\./g, "\\.?").replace(/,/g, ",?") + "\\s*$");
                            best_matches = potential_matches.filter(pm => pm.search(pm_reg) >= 0);
                        }
                    } else {
                        potential_name = "";
                    }
                }
            }
        }
        if (best_matches.length > 0) { add_to_map(page_mentions, best_matches[0]); }
        var name_reg = null;
        var name_rep = "";
        var sorted_pm = new Map([...page_mentions.entries()].sort(longer_name));
        for (let pm of sorted_pm.keys()) {
            //log("page_mentions: " + pm + " : " + sorted_pm.get(pm));
            var reg_pm = pm.replace(/\s+/, "\\s+");
            name_reg = new RegExp("(?<!>)" + reg_pm + "(?![<\\w<])", "g");
            name_rep = "<span class='hgreen'>" + pm + "</span>";
            html_text = html_text.replace(name_reg, name_rep);

            add_to_hot_names(pm);
        }
        var sorted_pc = new Map([...page_caps.entries()].sort(longer_name));
        for (let pc of sorted_pc.keys()) {
            //log("page_caps: " + pc);
            name_reg = new RegExp("(?<!>)" + pc + "(?![\\w<])", "g");
            name_rep = "<span class='hyellow'>" + pc + "</span>";
            html_text = html_text.replace(name_reg, name_rep);
        }

        update_hotkeys();

        $('#page_text').empty;
        $('#page_text').html(html_text.trim());
    }

    function longer_name(a, b) {
        return a.length - b.length;
    }

    function add_to_hot_names(name) {
        var in_hot_names = false;
        for (let value of hot_names.values()) {
            if (value[0] === name) {
                value[1] = 0;
                in_hot_names = true;
                break;
            }
        }
        if (!in_hot_names) {
            var high_val = 0;
            var high_key = null;
            for (let key of hot_names.keys()) {
                if (hot_names.get(key)[0] == "") {
                    high_key = key;
                    break;
                } else if (hot_names.get(key)[1] > high_val) {
                    high_key = key;
                    high_val = hot_names.get(key)[1];
                }
            }
            if (high_key != null) {
                hot_names.set(high_key, [name, 0]);
            } else {
                log("ERROR: Too many fresh names, no countermeasure yet");
            }
        }
    }

    function select_quote(quote) {
        var classes = quote.classList;
        $('.quote_div').removeClass("selected");
        $(quote).addClass("selected");
        if (classes.contains("assigned")) {
            $(quote).removeClass("assigned");
            //this nonsense works for now, but I should extract quote text somewhere/somehow else i think
            //now I have get_val working stably, but i'm scared to touch this
            var quote_text = quote.textContent;
            var quote_reg = new RegExp("\".*\"", "s");
            var quote_matches = quote_text.match(quote_reg);
            if (quote_matches != null) {
                quote.textContent = quote_matches[0];
            }
        }
    }

    function add_name() {
        //There's a bug here where if the user cancels the prompt, it prevents other hotkeys from functioning
        //ignoring for now
        var alias = prompt("Enter new name:", "").trim();
        if (alias === null) {
            log("ERROR: null prompt - need to refresh for hotkey functionality");
            return;
        }
        if (alias == "") {
            log("No Prompt Entry");
        } else {
            add_to_array(known_names, alias);
            add_to_hot_names(alias);
            process_page_text();
        }
    }

    function set_quote(args) {
        var all_quotes = document.getElementsByClassName('quote_div');
        var quote_div = null;
        var speaker = args[0];
        for (var i = 0, len = all_quotes.length | 0; i < len; i = i + 1) {
            quote_div = all_quotes[i];
            if (quote_div.classList.contains("selected")) {
                add_to_hot_names(speaker);
                var quote_text = quote_div.textContent;
                add_to_map(page_quotes, speaker, smart_split(quote_text).length);
                quote_div.setAttribute("class", "quote_div assigned");
                quote_div.innerHTML = quote_div.innerHTML + "<br /><br />Assigned: " + speaker;
                if (i + 1 < len) {
                    all_quotes[i + 1].setAttribute("class", "quote_div selected");
                }
                break;
            }
        }
    }

    function smart_split(input_text, separator = "\\s+", flags = "") {
        var input_trimmed = input_text.trim(separator);
        if (input_trimmed == "") {
            return []
        }
        var re = new RegExp(separator, flags);
        var ret_arr = input_trimmed.split(re);
        if (ret_arr[0] == "") { ret_arr.shift(); }
        if (ret_arr[ret_arr.length - 1] == "") { ret_arr.pop(); }
        return ret_arr
    }

    function mark_scene() {
        var next_words = prompt("Enter first words of next scene:", "");
        if (next_words === null) {
            log("ERROR: null prompt - need to refresh for hotkey functionality");
            return;
        }
        if (next_words === "") {
            log("No Prompt Entry");
        } else {
            var endpoint = page_text.indexOf(next_words);
            if (endpoint >= 0) {
                scene_end = endpoint;
                abs_char_count = page_start;
                last_page = true;
                next_page();
                set_val('save_status', "reviewing");
            }
        }
    }

    function generate_summary() {
        log("Generating Summary");
        //checking form fields
        var checked_fields = true;
        checked_fields = get_val('chapter_box') != "" & checked_fields;
        checked_fields = get_val('primary_box') != "" & checked_fields;
        checked_fields = get_val('locations_box') != "" & checked_fields;
        checked_fields = get_val('description_box') != "" & checked_fields;
        for (let fe of smart_split(get_val('features_box'), "[\\v\\r\\n]+")) {
            add_to_array(scene_features, fe);
        }
        if (!checked_fields) {
            log("ERROR: Scene fields empty");
            return;
        }
        //checking and updating last page
        if (!save_page_to_scene()) {
            log("ERROR: Quotes unassigned");
            return;
        }

        //transferring data to gen_form
        set_val('position', page_start);
        set_val('chapter', get_val('chapter_box'));
        set_val('primary', get_val('primary_box'));
        set_val('locations', get_val('locations_box'));
        set_val('description', get_val('description_box'));
        set_val('features', get_val('features_box'));
        set_val('wordcount', scene_wordcount);
        var sm_string = "";
        for (let [key, value] of scene_mentions.entries()) {
            sm_string = sm_string + key + "," + String(value) + "\n";
        }
        sm_string = sm_string.trim();
        set_val('mentions', sm_string);
        var sq_string = "";
        for (let [key, value] of scene_quotes.entries()) {
            sq_string = sq_string + key + "," + String(value) + "\n";
        }
        set_val('quotes', sq_string.trim());
        var ce_string = "";
        for (let ce of char_events) {
            ce_string = ce_string + [ce[0], ce[1].join(), ce[2].join(), ce[3].join()].join(";") + "\n";
        }
        ce_string = ce_string.trim();
        set_val('char_events', ce_string);
        var kn_string = "";
        for (let kn of known_names) {
            kn_string = kn_string + kn + "\n";
        }
        kn_string = kn_string.trim();
        set_val('known_names', kn_string);

        set_val('log', get_val('log_box'));
        $("#gen_form").submit();
    }

    function translate_summary() {
        set_val('log_box', get_val('log'));
        log("Translating summary data back into page");
        abs_char_count = Number(get_val('position'));
        set_val('chapter_box', get_val('chapter'));
        set_val('primary_box', get_val('primary'));
        set_val('locations_box', get_val('locations'));
        set_val('description_box', get_val('description'));
        set_val('features_box', get_val('features'));
        scene_wordcount = Number(get_val('wordcount'));
        scene_mentions = new Map();
        var sm_strings = smart_split(get_val('mentions'), "[\\v\\r\\n]+");
        for (let sm of sm_strings) {
            var sm_fields = sm.split(",");
            add_to_map(scene_mentions, sm_fields[0], sm_fields[1]);
        }
        scene_quotes = new Map();
        var sq_strings = smart_split(get_val('quotes'), "[\\v\\r\\n]+");
        for (let sq of sq_strings) {
            var sq_fields = sq.split(",");
            add_to_map(scene_quotes, sq_fields[0], sq_fields[1]);
        }
        char_events = []
        var ce_strings = smart_split(get_val('char_events'), "[\\v\\r\\n]+");
        for (let ce of ce_strings) {
            var ce_fields = ce.split(";");
            var ce_name = ce_fields[0];
            var ce_aliases = ce_fields[1].split(",");
            var ce_joins = ce_fields[2].split(",");
            var ce_tags = ce_fields[3].split(",");
            add_to_array(char_events, [ce_name, ce_aliases, ce_joins, ce_tags]);
        }
        scene_features = smart_split(get_val('features'), "[\\v\\r\\n]+");
        known_names = smart_split(get_val('known_names'), "[\\v\\r\\n]+");
    }

    function save_scene() {
        if (get_val('save_status') != "reviewing") {
            log("ERROR: cannot save until scene is parsed and reviewed!");
            return;
        }
        if (confirm("Are you sure you are ready to upload scene data?")) {
            log("Saving Scene Data to Database!");
            set_val('save_status', 'saved');
            generate_summary();
        }
    }
</script>